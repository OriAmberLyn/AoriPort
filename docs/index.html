<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Office Scene</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }

        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 14px;
            font-weight: bold;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="tooltip"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
<script>
    const canvas = document.getElementById("renderCanvas");
    const tooltip = document.getElementById("tooltip");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = async () => {
        const scene = new BABYLON.Scene(engine);

        // Camera setup
        const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 80, 0), scene);
        camera.rotation = new BABYLON.Vector3(
            0.4026,
            -2.5294 + Math.PI/1.6,
            0
        );
        camera.speed = 500;
        camera.inertia = 0;
        camera.angularSensibility = 500;
        camera.attachControl(canvas, true);

        // Light
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
        light.intensity = 0.9;

        // Load GLB
        const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "", 
            "https://raw.githubusercontent.com/OriAmberLyn/SiteAssets/edd67b281627d2115426c975dc07ccdf4532893c/", 
            "desk_asset%20(1).glb", 
            scene
        );

        // Remove Can_Momster object
        const canMomster = scene.getMeshByName("Can_Momster_M_Can_Momster_0");
        if (canMomster) canMomster.dispose();

        // Remove material from Monitor_Wide
        const monitorWide = scene.getMeshByName("Monitor_Wide_M_Monitor_Wide_Screen_0");
        if (monitorWide) monitorWide.material = null;

        // Scale all meshes
        result.meshes.forEach(mesh => mesh.scaling = new BABYLON.Vector3(1,1,1));

        // Clickable meshes with readable page labels
const clickableMeshes = {
    "Monitor_Wide_M_Monitor_Wide_Screen_0": { url: "about.html", label: "About Page" },
    "Keyboard_M_Keyboard_0": { url: "contact.html", label: "Contact Page" },
    "1_M_HUION_KAMVAS_GT_221_PRO_0": { url: "works.html", label: "Works Page" }
};

// Hover and click interactions
result.meshes.forEach(mesh => {
    const meshInfo = clickableMeshes[mesh.name];
    if(meshInfo) {
        mesh.actionManager = new BABYLON.ActionManager(scene);

        // Store original material (or create a temporary one if null)
        const originalMaterial = mesh.material;
        if(!mesh.material) {
            mesh.material = new BABYLON.StandardMaterial("tempMat", scene);
            mesh.material.diffuseColor = new BABYLON.Color3(1,1,1);
        }

        // Highlight on hover + tooltip
        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOverTrigger,
                function() {
                    if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(1,1,1);
                    tooltip.style.display = "block";
                    tooltip.textContent = meshInfo.label;
                }
            )
        );

        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPointerOutTrigger,
                function() {
                    if(mesh.material && originalMaterial)
                        mesh.material.diffuseColor = originalMaterial.diffuseColor.clone();
                    tooltip.style.display = "none";
                }
            )
        );

        // Click: zoom then navigate
        mesh.actionManager.registerAction(
            new BABYLON.ExecuteCodeAction(
                BABYLON.ActionManager.OnPickTrigger,
                function() {
                    const distance = 10;
                    const meshPos = mesh.getBoundingInfo().boundingBox.centerWorld;

                    const direction = camera.position.subtract(meshPos).normalize();
                    const targetPosition = meshPos.add(direction.scale(distance));

                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraZoom",
                        camera,
                        "position",
                        60, 60,
                        camera.position.clone(),
                        targetPosition,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );

                    BABYLON.Animation.CreateAndStartAnimation(
                        "cameraTarget",
                        camera,
                        "target",
                        60, 60,
                        camera.getTarget().clone(),
                        meshPos,
                        BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT
                    );

                    setTimeout(() => {
                        window.location.href = meshInfo.url;
                    }, 700);
                }
            )
        );
    }
});


      // Tooltip follows mouse
        scene.onPointerMove = function(evt) {
            tooltip.style.left = evt.clientX + 10 + "px";
            tooltip.style.top = evt.clientY + 10 + "px";
        };

        return scene;
    };

    createScene().then(scene => {
        engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
