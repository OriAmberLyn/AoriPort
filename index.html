<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Office Scene</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
            display: block;
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            display: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div id="tooltip"></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTF2FileLoader.js"></script>
<script>
    const canvas = document.getElementById("renderCanvas");
    const tooltip = document.getElementById("tooltip");
    const engine = new BABYLON.Engine(canvas, true);

    const createScene = async () => {
        const scene = new BABYLON.Scene(engine);

        // Camera setup
        const camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 80, 0), scene);
        camera.rotation = new BABYLON.Vector3(
            0.4026,
            -2.5294 + Math.PI/1.6,
            0
        );
        camera.speed = 500;
        camera.inertia = 0;
        camera.angularSensibility = 500;
        camera.attachControl(canvas, true);

        // Light
        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
        light.intensity = 0.9;

        // Load GLB
        const result = await BABYLON.SceneLoader.ImportMeshAsync(
            "", 
            "https://raw.githubusercontent.com/OriAmberLyn/SiteAssets/edd67b281627d2115426c975dc07ccdf4532893c/", 
            "desk_asset%20(1).glb", 
            scene
        );

        // Remove Can_Momster object
        const canMomster = scene.getMeshByName("Can_Momster_M_Can_Momster_0");
        if (canMomster) canMomster.dispose();

        // Remove material from Monitor_Wide
        const monitorWide = scene.getMeshByName("Monitor_Wide_M_Monitor_Wide_Screen_0");
        if (monitorWide) monitorWide.material = null;

        // Scale all meshes
        result.meshes.forEach(mesh => mesh.scaling = new BABYLON.Vector3(1,1,1));

        // Clickable meshes with Google Sites URLs
        const clickableMeshes = {
            "Monitor_Wide_M_Monitor_Wide_Screen_0": "https://sites.google.com/view/melodyport/about",
            "Keyboard_M_Keyboard_0": "https://sites.google.com/view/melodyport/contact",
            "1_M_HUION_KAMVAS_GT_221_PRO_0": "https://sites.google.com/view/melodyport/works"
        };

        // Hover and click interactions
        result.meshes.forEach(mesh => {
            if(clickableMeshes[mesh.name]) {
                mesh.actionManager = new BABYLON.ActionManager(scene);

                // Highlight on hover
                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOverTrigger,
                        function() {
                            mesh.originalColor = mesh.material ? mesh.material.diffuseColor.clone() : null;
                            if(mesh.material) mesh.material.diffuseColor = new BABYLON.Color3(1,1,0);
                            tooltip.style.display = "block";
                            tooltip.textContent = mesh.name;
                        }
                    )
                );

                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPointerOutTrigger,
                        function() {
                            if(mesh.material && mesh.originalColor) mesh.material.diffuseColor = mesh.originalColor;
                            tooltip.style.display = "none";
                        }
                    )
                );

                // Click: zoom camera then navigate on same tab
                mesh.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnPickTrigger,
                        function() {
                            const distance = 10;
                            const meshPos = mesh.getBoundingInfo().boundingBox.centerWorld;

                            // Move camera toward mesh
                            const direction = camera.position.subtract(meshPos).normalize();
                            const targetPosition = meshPos.add(direction.scale(distance));

                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraZoom",
                                camera,
                                "position",
                                60,
                                60,
                                camera.position.clone(),
                                targetPosition,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.CubicEase()
                            );

                            // Animate camera target to look at mesh
                            BABYLON.Animation.CreateAndStartAnimation(
                                "cameraTarget",
                                camera,
                                "target",
                                60,
                                60,
                                camera.getTarget().clone(),
                                meshPos,
                                BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT,
                                new BABYLON.CubicEase()
                            );

                            // Navigate after animation
                            setTimeout(() => {
                                const url = clickableMeshes[mesh.name];
                                window.location.href = url; // same tab
                            }, 700);
                        }
                    )
                );
            }
        });

        // Tooltip follows mouse
        scene.onPointerMove = function(evt) {
            tooltip.style.left = evt.clientX + 10 + "px";
            tooltip.style.top = evt.clientY + 10 + "px";
        };

        return scene;
    };

    createScene().then(scene => {
        engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>
